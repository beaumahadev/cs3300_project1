<html>

<head>
<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
body { font-family: 'Crimson Text', Calibri, sans-serif; }

path.lineGraph { fill: none; stroke-width: 2; }
</style>
</head>

	<body>

		<svg height="400" width="400" id="icon_plot" style="border: solid black 1px"></svg>
		<svg height="400" width="400"></svg>
		<svg width="480" height="400" id="sleepmap"></svg>
		<svg width="480" height="400" id="satisfactionmap"></svg>
		<svg width="480" height="400" id="incomemap"></svg>
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<script src="https://d3js.org/topojson.v2.min.js"></script>

		<script id = "Load Data">
			//All the code for loading from our tsv into arrys

			var satisfactionDict;
			var sleepDict;
			var incomeDict;
			var politicalDict;

			//creates a dictionary from given tsv given the colomn for the keys and the colomn for the values
			function createDataDict(tsv, col_key, col_value){ 
				var dict={};
				var newfunction= function(tsv, col_key, col_value){
					d3.tsv(tsv, function (error, data) {
					data.forEach(function(d) {
						var headings=Object.keys(d);
						dict[d[(headings[col_key])]]=d[(headings[col_value])];
					});
				});
					return dict;
				};
				return newfunction;
			}


			satisfactionDict=createDataDict()("hapiness.tsv",1,2);
			sleepDict=createDataDict()("sleep.tsv",0,1);
			incomeDict=createDataDict()("income.tsv",6,4);
			politicalDict=createDataDict()("political.tsv",0,1);


			  setTimeout(function() {
			    buildViz();
			  }, 250);
			  
				function buildScatterplot(sleepDict, incomeDict, satisfactionDict){
					var svg_icon = d3.select("#icon_plot");
					var keys =  Object.keys(sleepDict);
					var lifeExtent = d3.extent(keys,function (d) { if(d != "Delaware 50.65:" ){ return satisfactionDict[d];} });
					var sleepExtent = d3.extent(keys, function (d) { return sleepDict[d]; });
					var incomeExtent = d3.extent(keys, function (d) { return incomeDict[d]; });

					var areaScale = d3.scaleSqrt().domain(incomeExtent).range([10,50]);
					//areaScale(incomeDict[key])
					var xScale = d3.scaleLinear().domain(sleepExtent).range([50,325]);
					var yScale = d3.scaleLinear().domain(lifeExtent).range([325,50]); 

					keys.forEach(function (key) {
						if (key != "District of Columbia:"){
							console.log(key);
							console.log(satisfactionDict[key]);
							if(key == "Delaware"){
								svg_icon.append("image")
								.attr("xlink:href", "state_icons_t/Delaware.png")
								.attr("x", xScale(sleepDict[key]))
								.attr("y", yScale(50.65))
								.attr("width", areaScale(incomeDict[key]))
								.attr("height",areaScale(incomeDict[key]))
								.attr("opacity", .9);
							}
							else {
								var string = "state_icons_t/";
								var string_state = key.replace(" ","_");
								var image_link = string.concat(string_state,".png");
								svg_icon.append("image")
								.attr("xlink:href", image_link)
								.attr("x", xScale(sleepDict[key]))
								.attr("y", yScale(satisfactionDict[key]))
								.attr("width", areaScale(incomeDict[key]))
								.attr("height",areaScale(incomeDict[key]))
								.attr("opacity", .9);
							}
						}
					});
				}
			

			//create the visulization 
			function buildViz(){

				generateMaps();
			}




			function generateMaps(){
				
				var svgsleep = d3.select("#sleepmap");
				var svgsatisfaction= d3.select("#satisfactionmap");
				var svgincome= d3.select("#incomemap");
				var keys =  Object.keys(sleepDict);

				var path = d3.geoPath();
				var projection = d3.geoAlbersUsa().scale(75);

				var scaleSleep = d3.scaleQuantize()
    			.domain([50,72])
    			.range(["#b5d0ff","#b3b3ff", "#8080ff", "#4d4dff", "#1a1aff", "#0000e6", "#0000b3","#000080","#000066", "#00004d"]);

    			var scaleSatisfaction = d3.scaleQuantize()
    			.domain([30,72])
    			.range(['#b2e2e2','#66c2a4','#2ca25f','#006d2c']);

    			var scaleIncome = d3.scaleQuantize()
    			.domain([50000,70000])
    			.range(["#ffb380","#ff944d","#ff751a","#e65c00", "#993d00","#4d1f00"]);

				var states;

				d3.queue()
				.defer(d3.json, "us.json")
				.await(callback)
				//d3.json("us.json", callback);

				function callback (error, rawMap, rawUSDA) {
				  console.log("Code in the call-back function is only executed when every data file loads.");
				
				  states = topojson.feature(rawMap, rawMap.objects.states);
				  


				  showMap(scaleSleep, sleepDict, svgsleep,"Percentage of Population with 7+ Hours of Sleep");
				  showMap(scaleSatisfaction, satisfactionDict, svgsatisfaction, "Life Satisfaction Score");
				  showMap(scaleIncome, incomeDict, svgincome, "Medium Income");
				  buildScatterplot(sleepDict, incomeDict, satisfactionDict);
				}



				function showMap(scale, dict, svg, heading) {
				  // Create or modify paths for each country
				  

				  projection.fitExtent([[0,0], [svg.attr("width"), svg.attr("height")]], states);
				  pathGenerator = d3.geoPath().projection(projection);
				  
				  svg.append("text")
					.text(heading)
					.attr("x", 25)
					.attr("y", 25)
					.style("font-size", "12pt");

				  var paths = svg.selectAll("path.states").data(states.features);
				  
				  paths = paths.enter().append("path").attr("class", "country")
				  .on("click", function (d) { console.log("id: "+d.id); console.log("id state: "+keys[d.id-1]);})
				  .merge(paths);
				  
				  paths
				  .transition().duration(1000)
				  .style("fill", function (s) {
				    // Fill this in

				      	return scale(dict[keys[s.id-1]]);
				      
				    
				      
				  
				  })
				  .attr("d", function (county) {
				    return pathGenerator(county);
				  });
				  
				}

			}

			


			
</script>



</body>
</html>